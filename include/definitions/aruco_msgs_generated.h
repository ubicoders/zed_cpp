// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_ARUCOMSGS_ARUCO_H_
#define FLATBUFFERS_GENERATED_ARUCOMSGS_ARUCO_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
                  FLATBUFFERS_VERSION_MINOR == 3 &&
                  FLATBUFFERS_VERSION_REVISION == 25,
              "Non-compatible flatbuffers version included");

namespace ArUco
{

  struct Point2D;

  struct Marker;
  struct MarkerBuilder;

  struct ImageMarkers;
  struct ImageMarkersBuilder;

  struct StereoImageMarkers;
  struct StereoImageMarkersBuilder;

  FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4)
  Point2D FLATBUFFERS_FINAL_CLASS
  {
  private:
    float x_;
    float y_;

  public:
    Point2D()
        : x_(0),
          y_(0)
    {
    }
    Point2D(float _x, float _y)
        : x_(::flatbuffers::EndianScalar(_x)),
          y_(::flatbuffers::EndianScalar(_y))
    {
    }
    float x() const
    {
      return ::flatbuffers::EndianScalar(x_);
    }
    float y() const
    {
      return ::flatbuffers::EndianScalar(y_);
    }
  };
  FLATBUFFERS_STRUCT_END(Point2D, 8);

  struct Marker FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
  {
    typedef MarkerBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
      VT_ID = 4,
      VT_CORNERS = 6
    };
    int32_t id() const
    {
      return GetField<int32_t>(VT_ID, 0);
    }
    const ::flatbuffers::Vector<const ArUco::Point2D *> *corners() const
    {
      return GetPointer<const ::flatbuffers::Vector<const ArUco::Point2D *> *>(VT_CORNERS);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
      return VerifyTableStart(verifier) &&
             VerifyField<int32_t>(verifier, VT_ID, 4) &&
             VerifyOffset(verifier, VT_CORNERS) &&
             verifier.VerifyVector(corners()) &&
             verifier.EndTable();
    }
  };

  struct MarkerBuilder
  {
    typedef Marker Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_id(int32_t id)
    {
      fbb_.AddElement<int32_t>(Marker::VT_ID, id, 0);
    }
    void add_corners(::flatbuffers::Offset<::flatbuffers::Vector<const ArUco::Point2D *>> corners)
    {
      fbb_.AddOffset(Marker::VT_CORNERS, corners);
    }
    explicit MarkerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb)
    {
      start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<Marker> Finish()
    {
      const auto end = fbb_.EndTable(start_);
      auto o = ::flatbuffers::Offset<Marker>(end);
      return o;
    }
  };

  inline ::flatbuffers::Offset<Marker> CreateMarker(
      ::flatbuffers::FlatBufferBuilder &_fbb,
      int32_t id = 0,
      ::flatbuffers::Offset<::flatbuffers::Vector<const ArUco::Point2D *>> corners = 0)
  {
    MarkerBuilder builder_(_fbb);
    builder_.add_corners(corners);
    builder_.add_id(id);
    return builder_.Finish();
  }

  inline ::flatbuffers::Offset<Marker> CreateMarkerDirect(
      ::flatbuffers::FlatBufferBuilder &_fbb,
      int32_t id = 0,
      const std::vector<ArUco::Point2D> *corners = nullptr)
  {
    auto corners__ = corners ? _fbb.CreateVectorOfStructs<ArUco::Point2D>(*corners) : 0;
    return ArUco::CreateMarker(
        _fbb,
        id,
        corners__);
  }

  struct ImageMarkers FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
  {
    typedef ImageMarkersBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
      VT_IMAGE_NAME = 4,
      VT_MARKERS = 6
    };
    const ::flatbuffers::String *image_name() const
    {
      return GetPointer<const ::flatbuffers::String *>(VT_IMAGE_NAME);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<ArUco::Marker>> *markers() const
    {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ArUco::Marker>> *>(VT_MARKERS);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
      return VerifyTableStart(verifier) &&
             VerifyOffset(verifier, VT_IMAGE_NAME) &&
             verifier.VerifyString(image_name()) &&
             VerifyOffset(verifier, VT_MARKERS) &&
             verifier.VerifyVector(markers()) &&
             verifier.VerifyVectorOfTables(markers()) &&
             verifier.EndTable();
    }
  };

  struct ImageMarkersBuilder
  {
    typedef ImageMarkers Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_image_name(::flatbuffers::Offset<::flatbuffers::String> image_name)
    {
      fbb_.AddOffset(ImageMarkers::VT_IMAGE_NAME, image_name);
    }
    void add_markers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ArUco::Marker>>> markers)
    {
      fbb_.AddOffset(ImageMarkers::VT_MARKERS, markers);
    }
    explicit ImageMarkersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb)
    {
      start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<ImageMarkers> Finish()
    {
      const auto end = fbb_.EndTable(start_);
      auto o = ::flatbuffers::Offset<ImageMarkers>(end);
      return o;
    }
  };

  inline ::flatbuffers::Offset<ImageMarkers> CreateImageMarkers(
      ::flatbuffers::FlatBufferBuilder &_fbb,
      ::flatbuffers::Offset<::flatbuffers::String> image_name = 0,
      ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ArUco::Marker>>> markers = 0)
  {
    ImageMarkersBuilder builder_(_fbb);
    builder_.add_markers(markers);
    builder_.add_image_name(image_name);
    return builder_.Finish();
  }

  inline ::flatbuffers::Offset<ImageMarkers> CreateImageMarkersDirect(
      ::flatbuffers::FlatBufferBuilder &_fbb,
      const char *image_name = nullptr,
      const std::vector<::flatbuffers::Offset<ArUco::Marker>> *markers = nullptr)
  {
    auto image_name__ = image_name ? _fbb.CreateString(image_name) : 0;
    auto markers__ = markers ? _fbb.CreateVector<::flatbuffers::Offset<ArUco::Marker>>(*markers) : 0;
    return ArUco::CreateImageMarkers(
        _fbb,
        image_name__,
        markers__);
  }

  struct StereoImageMarkers FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
  {
    typedef StereoImageMarkersBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
      VT_LEFT_IMAGE = 4,
      VT_RIGHT_IMAGE = 6
    };
    const ArUco::ImageMarkers *left_image() const
    {
      return GetPointer<const ArUco::ImageMarkers *>(VT_LEFT_IMAGE);
    }
    const ArUco::ImageMarkers *right_image() const
    {
      return GetPointer<const ArUco::ImageMarkers *>(VT_RIGHT_IMAGE);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
      return VerifyTableStart(verifier) &&
             VerifyOffset(verifier, VT_LEFT_IMAGE) &&
             verifier.VerifyTable(left_image()) &&
             VerifyOffset(verifier, VT_RIGHT_IMAGE) &&
             verifier.VerifyTable(right_image()) &&
             verifier.EndTable();
    }
  };

  struct StereoImageMarkersBuilder
  {
    typedef StereoImageMarkers Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_left_image(::flatbuffers::Offset<ArUco::ImageMarkers> left_image)
    {
      fbb_.AddOffset(StereoImageMarkers::VT_LEFT_IMAGE, left_image);
    }
    void add_right_image(::flatbuffers::Offset<ArUco::ImageMarkers> right_image)
    {
      fbb_.AddOffset(StereoImageMarkers::VT_RIGHT_IMAGE, right_image);
    }
    explicit StereoImageMarkersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb)
    {
      start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<StereoImageMarkers> Finish()
    {
      const auto end = fbb_.EndTable(start_);
      auto o = ::flatbuffers::Offset<StereoImageMarkers>(end);
      return o;
    }
  };

  inline ::flatbuffers::Offset<StereoImageMarkers> CreateStereoImageMarkers(
      ::flatbuffers::FlatBufferBuilder &_fbb,
      ::flatbuffers::Offset<ArUco::ImageMarkers> left_image = 0,
      ::flatbuffers::Offset<ArUco::ImageMarkers> right_image = 0)
  {
    StereoImageMarkersBuilder builder_(_fbb);
    builder_.add_right_image(right_image);
    builder_.add_left_image(left_image);
    return builder_.Finish();
  }

  inline const ArUco::StereoImageMarkers *GetStereoImageMarkers(const void *buf)
  {
    return ::flatbuffers::GetRoot<ArUco::StereoImageMarkers>(buf);
  }

  inline const ArUco::StereoImageMarkers *GetSizePrefixedStereoImageMarkers(const void *buf)
  {
    return ::flatbuffers::GetSizePrefixedRoot<ArUco::StereoImageMarkers>(buf);
  }

  inline const char *StereoImageMarkersIdentifier()
  {
    return "ODET";
  }

  inline bool StereoImageMarkersBufferHasIdentifier(const void *buf)
  {
    return ::flatbuffers::BufferHasIdentifier(
        buf, StereoImageMarkersIdentifier());
  }

  inline bool SizePrefixedStereoImageMarkersBufferHasIdentifier(const void *buf)
  {
    return ::flatbuffers::BufferHasIdentifier(
        buf, StereoImageMarkersIdentifier(), true);
  }

  inline bool VerifyStereoImageMarkersBuffer(
      ::flatbuffers::Verifier &verifier)
  {
    return verifier.VerifyBuffer<ArUco::StereoImageMarkers>(StereoImageMarkersIdentifier());
  }

  inline bool VerifySizePrefixedStereoImageMarkersBuffer(
      ::flatbuffers::Verifier &verifier)
  {
    return verifier.VerifySizePrefixedBuffer<ArUco::StereoImageMarkers>(StereoImageMarkersIdentifier());
  }

  inline void FinishStereoImageMarkersBuffer(
      ::flatbuffers::FlatBufferBuilder &fbb,
      ::flatbuffers::Offset<ArUco::StereoImageMarkers> root)
  {
    fbb.Finish(root, StereoImageMarkersIdentifier());
  }

  inline void FinishSizePrefixedStereoImageMarkersBuffer(
      ::flatbuffers::FlatBufferBuilder &fbb,
      ::flatbuffers::Offset<ArUco::StereoImageMarkers> root)
  {
    fbb.FinishSizePrefixed(root, StereoImageMarkersIdentifier());
  }

} // namespace ArUco

#endif // FLATBUFFERS_GENERATED_ARUCOMSGS_ARUCO_H_
